<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C++ Hidden Gems: Coroutines | GitHub Blog Clone</title>
    <link rel="stylesheet" href="/My-blog-App/css/style.css">
  </head>
  <body>
    <header class="header">
      <div class="container">
        <a href="/My-blog-App/" class="logo">GitHub Blog</a>
        <nav class="nav" aria-label="Main navigation">
          <a href="/My-blog-App/tags/ai/">AI & ML</a>
          <a href="/My-blog-App/tags/development/">Developer skills</a>
          <a href="/My-blog-App/tags/engineering/">Engineering</a>
          <a href="/My-blog-App/tags/enterprise/">Enterprise software</a>
          <a href="/My-blog-App/tags/news/">News & insights</a>
          <a href="/My-blog-App/tags/open-source/">Open Source</a>
          <a href="/My-blog-App/tags/security/">Security</a>
        </nav>
      </div>
      <div class="container">
        <nav class="nav-categories">
          <a href="/My-blog-App/ai-ml/">AI & ML</a>
          <a href="/My-blog-App/developer-skills/">Developer skills</a>
          <a href="/My-blog-App/engineering/">Engineering</a>
          <a href="/My-blog-App/enterprise-software/">Enterprise software</a>
          <a href="/My-blog-App/news-insights/">News & insights</a>
          <a href="/My-blog-App/open-source/">Open Source</a>
          <a href="/My-blog-App/security/">Security</a>
        </nav>
      </div>
    </header>

    <main class="main">
      <div class="container">
        
<article class="post-full">
  <header class="post-full-header">
    <h1 class="post-full-title">C++ Hidden Gems: Coroutines</h1>
    <p class="post-full-meta">
        By Jules on <time datetime="2024-09-26">September 26, 2024</time>
    </p>
  </header>

  
  <figure class="post-full-image">
    <img src="/images/post-5-thumbnail.svg" alt="C++ Hidden Gems: Coroutines" />
  </figure>
  

  <section class="post-full-content">
    <p>Asynchronous programming is becoming increasingly important in modern software development, but it can be challenging to write and reason about. Traditional approaches like callbacks and futures can lead to complex and hard-to-read code.</p>
<p>C++20 introduced a powerful new feature that aims to simplify asynchronous programming: <strong>coroutines</strong>.</p>
<h2>What are Coroutines?</h2>
<p>A coroutine is a function that can be suspended and resumed. It allows you to write asynchronous code in a way that looks and feels like synchronous code. When a coroutine is suspended, it returns control to the caller, and its state is saved. It can then be resumed later from where it left off.</p>
<h2>The <code>co_await</code>, <code>co_yield</code>, and <code>co_return</code> Keywords</h2>
<p>C++20 introduces three new keywords for working with coroutines:</p>
<ul>
<li><strong><code>co_await</code>:</strong> This keyword suspends the coroutine and waits for an operation to complete. For example, you could <code>co_await</code> a network request.</li>
<li><strong><code>co_yield</code>:</strong> This keyword is used to produce a value from a coroutine, making it act like a generator.</li>
<li><strong><code>co_return</code>:</strong> This keyword is used to return a value from a coroutine.</li>
</ul>
<h2>Coroutines as Generators</h2>
<p>One of the simplest ways to understand coroutines is to see how they can be used to create generators. A generator is a function that can produce a sequence of values on demand.</p>
<p>Here's an example of a simple generator that produces a sequence of integers:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;coroutine&gt;
#include &lt;ranges&gt;

// A simple generator type (requires a more complex implementation in practice)
struct generator {
    struct promise_type {
        int current_value;
        auto get_return_object() { return generator{handle_type::from_promise(*this)}; }
        auto initial_suspend() { return std::suspend_always{}; }
        auto final_suspend() noexcept { return std::suspend_always{}; }
        void unhandled_exception() {}
        void return_void() {}
        auto yield_value(int value) {
            current_value = value;
            return std::suspend_always{};
        }
    };
    using handle_type = std::coroutine_handle&lt;promise_type&gt;;
    handle_type coro;

    generator(handle_type h) : coro(h) {}
    ~generator() { if (coro) coro.destroy(); }
    int operator()() {
        coro.resume();
        return coro.promise().current_value;
    }
};

generator count_to(int n) {
    for (int i = 0; i &lt; n; ++i) {
        co_yield i;
    }
}

int main() {
    auto gen = count_to(5);
    for (int i = 0; i &lt; 5; ++i) {
        std::cout &lt;&lt; gen() &lt;&lt; &quot; &quot;; // Prints 0 1 2 3 4
    }
}
</code></pre>
<p><em>(Note: The implementation of a generator type is complex and beyond the scope of this post. The example above is a simplified illustration.)</em></p>
<p>The <code>count_to</code> function is a coroutine. Each time <code>co_yield</code> is called, the function is suspended, and a value is produced.</p>
<h2>Coroutines for Asynchronous Programming</h2>
<p>The primary motivation for coroutines is to simplify asynchronous programming. With coroutines, you can write asynchronous code that looks like this:</p>
<pre><code class="language-cpp">// This is a conceptual example. `async_read` would return an &quot;awaitable&quot; object.
task&lt;std::string&gt; read_file_async(const std::string&amp; filename) {
    auto file = co_await open_file_async(filename);
    auto buffer = co_await file.read_async();
    co_return buffer;
}
</code></pre>
<p>This code looks synchronous, but the <code>co_await</code> keywords indicate that the function may be suspended at these points. This makes the code much easier to read and reason about than a callback-based approach.</p>
<h2>The Coroutine Framework is a Library Feature</h2>
<p>One of the unique things about C++ coroutines is that they are designed as a language feature that is implemented by libraries. The meaning of <code>co_await</code>, <code>co_yield</code>, and <code>co_return</code> is determined by the return type of the coroutine. This makes the C++ coroutine framework incredibly flexible and powerful, but it also means that there is a bit of a learning curve.</p>
<p>To use coroutines, you will typically use a library that provides the necessary &quot;awaitable&quot; and &quot;promise&quot; types, such as <code>cppcoro</code> or the networking library Asio.</p>
<h2>Conclusion</h2>
<p>Coroutines are one of the most significant and complex features of C++20. They represent a fundamental shift in how we write concurrent and asynchronous code in C++. While the learning curve can be steep, the benefits in terms of code readability and maintainability are enormous.</p>
<p>Coroutines are a hidden gem that will unlock new possibilities for writing high-performance, asynchronous C++ code. As libraries provide better support for coroutines, they are likely to become the standard way to write asynchronous code in C++. It's a powerful feature that is shaping the future of the language. It's a new tool for a new era of programming.</p>

  </section>
</article>

      </div>
    </main>

    <footer class="footer">
      <div class="container">
        <div class="footer-content">
            <div class="footer-section">
                <h4>Product</h4>
                <ul>
                    <li><a href="#">Features</a></li>
                    <li><a href="/My-blog-App/tags/security/">Security</a></li>
                    <li><a href="#">Enterprise</a></li>
                    <li><a href="#">Customer Stories</a></li>
                    <li><a href="#">Pricing</a></li>
                    <li><a href="#">Resources</a></li>
                </ul>
            </div>
            <div class="footer-section">
                <h4>Platform</h4>
                <ul>
                    <li><a href="/My-blog-App/tags/api/">Developer API</a></li>
                    <li><a href="#">Partners</a></li>
                    <li><a href="#">Atom</a></li>
                    <li><a href="#">Electron</a></li>
                    <li><a href="#">GitHub Desktop</a></li>
                </ul>
            </div>
            <div class="footer-section">
                <h4>Support</h4>
                <ul>
                    <li><a href="#">Docs</a></li>
                    <li><a href="#">Community Forum</a></li>
                    <li><a href="#">Training</a></li>
                    <li><a href="#">Status</a></li>
                    <li><a href="/My-blog-App/contact/">Contact</a></li>
                </ul>
            </div>
            <div class="footer-section">
                <h4>Company</h4>
                <ul>
                    <li><a href="/My-blog-App/about/">About</a></li>
                    <li><a href="/My-blog-App/blog/">Blog</a></li>
                    <li><a href="#">Careers</a></li>
                    <li><a href="#">Press</a></li>
                    <li><a href="#">Shop</a></li>
                </ul>
            </div>
        </div>
        <div class="footer-bottom">
            <p class="copyright">&copy; 2025 GitHub, Inc. All rights reserved.</p>
            <div class="footer-social-links">
                <a href="#">X</a>
                <a href="#">LinkedIn</a>
                <a href="#">YouTube</a>
                <a href="#">Twitch</a>
                <a href="#">TikTok</a>
            </div>
        </div>
      </div>
    </footer>
    <script src="/My-blog-App/js/main.js"></script>
  </body>
</html>
