<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C++ Hidden Gems: `std::variant` and `std::visit` | My Tech Blog</title>
    <link rel="stylesheet" href="/My-blog-App/css/style.css">
  </head>
  <body>
    <header class="header">
      <div class="container">
        <a href="/My-blog-App/" class="logo">My Tech Blog</a>
        <div class="nav-wrapper">
          <nav class="nav">
            <a href="/My-blog-App/">Home</a>
            <a href="/My-blog-App/blog/">Blog</a>
            <a href="/My-blog-App/about/">About</a>
            <a href="/My-blog-App/contact/">Contact</a>
          </nav>
          <button id="theme-toggle" class="theme-toggle" aria-label="Toggle dark mode">ðŸŒ™</button>
        </div>
      </div>
    </header>

    <main class="main">
      <div class="container">
        
<article class="post">
  <header class="post-header">
    <h1 class="post-title">C++ Hidden Gems: `std::variant` and `std::visit`</h1>
    <div class="post-meta">
      <span>By Jules</span>
      <img src="/assets/images/author-jules.svg" alt="Photo of Jules" class="author-image">
      <span> on <time datetime="2024-09-21">September 21, 2024</time></span>
    </div>
    
      <img src="/assets/images/post-13-thumbnail.svg" alt="Thumbnail for C++ Hidden Gems: `std::variant` and `std::visit`" class="post-thumbnail">
    
  </header>

  <div class="post-content">
    <p>C++ has long had C-style unions, but they are not type-safe and can be tricky to use correctly. C++17 introduced a modern, type-safe alternative: <code>std::variant</code>. A <code>std::variant</code> is a type-safe union that can hold a value from a set of specified types.</p>
<h2>What is <code>std::variant</code>?</h2>
<p>A <code>std::variant&lt;T, U, V&gt;</code> can hold a value of type <code>T</code>, <code>U</code>, or <code>V</code>. It will always hold a value of one of its specified types; it cannot be empty (unlike <code>std::optional</code>).</p>
<pre><code class="language-cpp">#include &lt;variant&gt;
#include &lt;string&gt;

int main() {
    std::variant&lt;int, std::string&gt; v;
    v = 10; // v now holds an int
    v = &quot;hello&quot;; // v now holds a std::string
}
</code></pre>
<h2>Accessing the Value in a <code>std::variant</code></h2>
<p>There are a few ways to access the value in a <code>std::variant</code>.</p>
<ul>
<li><strong><code>std::get</code>:</strong> You can use <code>std::get</code> with either a type or an index. If the variant does not hold the specified type, it will throw a <code>std::bad_variant_access</code> exception.</li>
</ul>
<pre><code class="language-cpp">std::variant&lt;int, std::string&gt; v = &quot;hello&quot;;
std::string s = std::get&lt;std::string&gt;(v);
// int i = std::get&lt;int&gt;(v); // Throws std::bad_variant_access
</code></pre>
<ul>
<li><strong><code>std::get_if</code>:</strong> This is a safer alternative that returns a pointer to the value if the variant holds the specified type, and <code>nullptr</code> otherwise.</li>
</ul>
<pre><code class="language-cpp">if (auto p = std::get_if&lt;std::string&gt;(&amp;v)) {
    std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; *p &lt;&lt; std::endl;
}
</code></pre>
<h2>The Power of <code>std::visit</code></h2>
<p>The most powerful way to work with a <code>std::variant</code> is <code>std::visit</code>. <code>std::visit</code> takes a &quot;visitor&quot; (a callable object, like a lambda) and a variant, and it calls the visitor with the value that is currently stored in the variant.</p>
<p>This allows you to handle all of the possible types in the variant in a clean and type-safe way.</p>
<pre><code class="language-cpp">#include &lt;variant&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

int main() {
    std::variant&lt;int, std::string&gt; v = &quot;hello&quot;;

    std::visit([](auto&amp;&amp; arg) {
        using T = std::decay_t&lt;decltype(arg)&gt;;
        if constexpr (std::is_same_v&lt;T, int&gt;) {
            std::cout &lt;&lt; &quot;It's an int: &quot; &lt;&lt; arg &lt;&lt; std::endl;
        } else if constexpr (std::is_same_v&lt;T, std::string&gt;) {
            std::cout &lt;&lt; &quot;It's a string: &quot; &lt;&lt; arg &lt;&lt; std::endl;
        }
    }, v);
}
</code></pre>
<p>This pattern of using a generic lambda with <code>if constexpr</code> is a common and powerful way to work with <code>std::visit</code>.</p>
<h2>Why Use <code>std::variant</code>?</h2>
<p><code>std::variant</code> is a great tool for representing a value that can be one of a fixed set of types. It's often used for things like:</p>
<ul>
<li><strong>Representing the states of a state machine.</strong></li>
<li><strong>Representing the different types of nodes in a tree or a graph.</strong></li>
<li><strong>Returning different types of values from a function.</strong></li>
</ul>
<p>It provides a more modern, type-safe, and expressive alternative to using unions or inheritance for these kinds of problems.</p>
<h2>Conclusion</h2>
<p><code>std::variant</code> is a powerful and flexible tool that is a great addition to the C++ standard library. It provides a type-safe way to work with values that can have different types. When combined with <code>std::visit</code>, it allows you to write clean, expressive, and safe code for handling these types of situations.</p>
<p>If you're not yet familiar with <code>std::variant</code>, I highly recommend taking the time to learn it. It's a hidden gem that can help you to write more robust and modern C++ code. It's a key part of the C++17 revolution.</p>

  </div>
</article>

      </div>
    </main>

    <footer class="footer">
      <div class="container">
        <p>&copy; 2024 My Tech Blog. All rights reserved.</p>
      </div>
    </footer>
    <script src="/My-blog-App/js/main.js"></script>
  </body>
</html>
